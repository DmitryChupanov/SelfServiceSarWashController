#include "MyUSART_FCs.h"
#include "stm32f1xx.h"
#include "cmsis_os.h"
#include "MyDefines.h"


/********************************************************* Это функция начальной инициализации USART5 ************************************************/
//Перед запуском этой функции нужно инициализировать UART5.
void USART5_Transmit_Init (void)
{
	//UART5->CR1 |= USART_CR1_TXEIE;										// 
	NVIC_EnableIRQ(UART5_IRQn);													// Разрешение прерываний
	__enable_irq ();																		// Глобальное разрешение прерываний
}
/*****************************************************************************************************************************************************/
/*************************** Это функция начальной инициализации DMA2 для приема данных из USART4 в буфер ********************************************/
//Перед запуском этой функции нужно инициализировать UART4.
void UART4_DMA_Receive_Init (uint8_t* MemRxDataP, uint32_t BufSize)
{
	RCC->AHBENR |= RCC_AHBENR_DMA2EN;										//Разрешаем тактирование DMA1
	DMA2_Channel3 -> CCR &= ~DMA_CCR_EN;								//Запрещение канала 3 DMA2  (это канал на прием UART4)
	osDelay(1);
	DMA2_Channel3 -> CPAR = (uint32_t)(&(UART4->DR));	//Указываем регистр данных UART4, откуда нужно забирать данные
	DMA2_Channel3 -> CNDTR = BufSize;										//Указываем размер буфера для циклической записи в него
	DMA2_Channel3 -> CMAR = (uint32_t) MemRxDataP;			//Указываем адрес памяти куда складывать данные
	DMA2_Channel3 -> CCR = (DMA_CCR_MINC|DMA_CCR_CIRC); //Вкл инкрементирование адреса чтения из памяти|включение кольцевого режима
	DMA2->IFCR |= DMA_IFCR_CGIF3|DMA_IFCR_CTCIF3|DMA_IFCR_CHTIF3|DMA_IFCR_CTEIF3; // Сброс флага глобального прерывания|флага завершения передачи|флага половинной передачи|флага ошибки передачи
	//USART2 -> CR1 |= USART_CR1_RXNEIE; 									//Разрешение прерывания если регистр приема данных не пуст
	UART4 -> CR3 |= USART_CR3_DMAR; 										//Подключение приемника USART к DMA
	DMA2_Channel3 -> CCR |= DMA_CCR_EN;									//Разрешение канала 3 DMA2  (это канал на прием USART4)
//	__enable_irq ();																		// Глобальное разрешение прерываний
//	NVIC_EnableIRQ(USART2_IRQn);												// Разрешение прерываний от USART2
}
/*****************************************************************************************************************************************************/
/*********************** Это функция начальной инициализации DMA2 для передачи данных из памяти в регистр данных UART4 *******************************/
//Перед запуском этой функции нужно инициализировать UART2.
void UART4_DMA_Transmit_Init (void)
{
	RCC->AHBENR |= RCC_AHBENR_DMA2EN;										//Разрешаем тактирование DMA2
	DMA2_Channel5 -> CCR &= ~DMA_CCR_EN;								//Запрет канала 5 DMA2  (это канал на передачу USART4)
	osDelay(1);
	DMA2_Channel5 -> CPAR = (uint32_t)(&(UART4->DR));		//Указываем регистр данных USART4, куда нужно отправлять данные
	DMA2_Channel5 -> CCR = (DMA_CCR_DIR|DMA_CCR_MINC); 	//Чтение из памяти|вкл инкрементирование адреса чтения из памяти
	DMA2->IFCR |= DMA_IFCR_CGIF5|DMA_IFCR_CTCIF5|DMA_IFCR_CHTIF5|DMA_IFCR_CTEIF5; // Сброс флага глобального прерывания|флага завершения передачи|флага половинной передачи|флага ошибки передачи
	UART4 -> CR3 |= USART_CR3_DMAT; 										//Подключение передатчика USART к DMA
	//USART1 ->SR &= ~USART_SR_TC;												// 
	DMA2_Channel5 -> CCR |= DMA_CCR_EN|DMA_CCR_TCIE;		// Разрешение канала 5 DMA2 и прерывания по завершении передачи  (это канал на передачу USART4)
	__enable_irq ();																		// Глобальное разрешение прерываний
	NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);								// Разрешение прерываний от 4 и 5 канала DMA2
}
/*****************************************************************************************************************************************************/

/**********************Отправка даныых из контроллера через UART2,DMA1 канал 7************************************************************************/
// uint8_t* USART2_TxDataP - указатель на адрес данных начиная с которого нужно передавать данные.
// uint16_t DatLen - количество байт данных, которое надо передать начиная с адреса uint8_t* USART2_TxDataP
// Перед первым запуском этой функции нужно последовательно проинициализировать UART2 и запустить функцию USART2_DMA_Transmit_Init ()
// Если предыдущая передача не закончилась или интерфейс не инициализирован (void USART1_DMA_Transmit_Init (void)), то функция ничего делать не будет.
USART_DMA_TransmitStatus UART4_DMA_Transmit (uint8_t* UART4_TxDataP, uint16_t DatLen)
{
	//if ((UART4 -> CR3 & USART_CR3_DMAT)== 0) return USART_NotInit;	// Если интерфейс не инициализирован
	if((UART4 ->SR & USART_SR_TC))																	// Если предыдущая передача закончилась
	{
		osDelay(1);
		RS485PC_TransmitON																		// Драйвер RS-485 конфигурируется на передачу
		DMA2_Channel5 -> CCR &= ~DMA_CCR_EN;								// Запрещение канала 5 DMA2  (это канал на передачу UART4)
		DMA2->IFCR |= DMA_IFCR_CGIF5|DMA_IFCR_CTCIF5|DMA_IFCR_CHTIF5|DMA_IFCR_CTEIF5; // Сброс флага глобального прерывания|флага завершения передачи|флага половинной передачи|флага ошибки передачи
		DMA2_Channel5 -> CMAR = (uint32_t) UART4_TxDataP;		// Записываем в ДМА адрес регистра, откуда забираются данные в ОЗУ
		DMA2_Channel5 ->CNDTR = DatLen;											// Указываем количество передач, которые надо сделать
		UART4 ->SR &= ~USART_SR_TC;													// Сброс бита завершения передачи
		DMA2_Channel5 -> CCR |= DMA_CCR_EN;									// Разрешение канала 5 DMA2  (это канал на передачу UART4)
		return USART_OK;
	}
	else																														// Если предыдущая передача не закончилась
	{
		return USART_Bisy;
	}
}
/*****************************************************************************************************************************************************/

/************************************** Функция читает данные из буфера и передает в порт RS485 ******************************************************/
#pragma push
#pragma O0
void PC_RS485Send(void)
{
	if (PC_TxBuf1p!=PC_TxBuf2p)																					// Проверяем, появилось ли что - нибудь для отправки в отладочный порт
	{
		if (RS485PC_TransferCompleted == 1)																// Если предыдущая передача по Отладочному порту через DMA завершена
		{
			RS485PC_TransferCompleted = 0;																	//Сбрасываем флаг завершения передачи через RS485
			if (PC_TxBuf1p>PC_TxBuf2p)																			//Если убегающий указатель больше догоняющего
			{
				uint16_t SendDataLen = PC_TxBuf1p - PC_TxBuf2p;								//То вычисляем длину куска, который нужно передать
				UART4_DMA_Transmit (&PC_TxBuf[PC_TxBuf2p], SendDataLen);			//Передаем кусок данных через DMA
				PC_TxBuf2p = PC_TxBuf2p+SendDataLen;												//Приравниваем догоняющую метку к убегающей
			}
			else if (PC_TxBuf1p<PC_TxBuf2p)
			{
				uint16_t SendDataLen1 = PC_TxBufSize - PC_TxBuf2p;							// Вычисляем длину куска, который нужно передать до конца буфера
				uint16_t SendDataLen2 = PC_TxBuf1p;															// Вычисляем длину куска, который нужно передать от начала буфера
				uint16_t SendDataLen = SendDataLen1 + SendDataLen2;							// Суммарная длина данных, которые нужно передать
				uint8_t TmpBuf[SendDataLen1 + SendDataLen2+1];
				for(uint16_t i = 0; i < SendDataLen; i++)
				{
					TmpBuf[i] = PC_TxBuf[PC_TxBuf2p++];
					PC_TxBuf2p %= PC_TxBufSize;																		// Закольцовка
				}
				UART4_DMA_Transmit (TmpBuf, SendDataLen);										//Передаем кусок данных через DMA
				for(uint32_t i = 0; i < 100000 ; i++)
				{
					if((UART4 ->SR & USART_SR_TC)!=0)
					{
						break;
					}
				}
			}
		}
	}
}
#pragma pop
/*****************************************************************************************************************************************************/

/*****************************************************************************************************************************************************/
void PrnToPc(char* Str)
{
	for(uint8_t i = 0; i < 100; i++)
	{
		if(*(Str + i) == 0)
		{
			break;
		}
		PC_TxBuf[PC_TxBuf1p++] = *(Str + i);
		PC_TxBuf1p %= PC_TxBufSize;
	}
	
}
/*****************************************************************************************************************************************************/

/*********************** Это функция начальной инициализации DMA1 для передачи данных из памяти в регистр данных USART2 *****************************/
//Перед запуском этой функции нужно инициализировать UART2.
void USART2_DMA_Transmit_Init (void)
{
	RCC->AHBENR |= RCC_AHBENR_DMA1EN;										//Разрешаем тактирование DMA1
	DMA1_Channel7 -> CCR &= ~DMA_CCR_EN;								//Запрещение канала 7 DMA1  (это канал на передачу USART1)
	osDelay(1);
	
	DMA1_Channel7 -> CPAR = (uint32_t)(&(USART2->DR));	//Указываем регистр данных USART2, куда нужно отправлять данные
	DMA1_Channel7 -> CCR = (DMA_CCR_DIR|DMA_CCR_MINC); 	//Чтение из памяти|вкл инкрементирование адреса чтения из памяти
	DMA1->IFCR |= DMA_IFCR_CGIF7|DMA_IFCR_CTCIF7|DMA_IFCR_CHTIF7|DMA_IFCR_CTEIF7; // Сброс флага глобального прерывания|флага завершения передачи|флага половинной передачи|флага ошибки передачи
	USART2 -> CR3 |= USART_CR3_DMAT; 										//Подключение передатчика USART к DMA
	//USART1 ->SR &= ~USART_SR_TC;												// 
	DMA1_Channel7 -> CCR |= DMA_CCR_EN;//|DMA_CCR_TCIE;		// Разрешение канала 7 DMA1 и прерывания по завершении передачи  (это канал на передачу USART2)
	//__enable_irq ();																		// Глобальное разрешение прерываний
	//NVIC_EnableIRQ(DMA1_Channel7_IRQn);									// Разрешение прерываний от седьмого канала DMA1
}
/*****************************************************************************************************************************************************/

/**********************Отправка даныых из контроллера через UART2,DMA1 канал 7************************************************************************/
// uint8_t* USART2_TxDataP - указатель на адрес данных начиная с которого нужно передавать данные.
// uint16_t DatLen - количество байт данных, которое надо передать начиная с адреса uint8_t* USART2_TxDataP
// Перед первым запуском этой функции нужно последовательно проинициализировать UART2 и запустить функцию USART2_DMA_Transmit_Init ()
// Если предыдущая передача не закончилась или интерфейс не инициализирован (void USART1_DMA_Transmit_Init (void)), то функция ничего делать не будет.
USART_DMA_TransmitStatus USART2_DMA_Transmit (uint8_t* USART2_TxDataP, uint16_t DatLen)
{
	if ((USART2 -> CR3 & USART_CR3_DMAT)== 0) return USART_NotInit;	// Если интерфейс не инициализирован
	if((USART2 ->SR & USART_SR_TC))																	// Если предыдущая передача закончилась
	{
		//RS485_TransmitON																		// Драйвер RS-485 конфигурируется на передачу
		//osDelay(10);
		DMA1_Channel7 -> CCR &= ~DMA_CCR_EN;								// Запрещение канала 7 DMA1  (это канал на передачу USART2)
		DMA1->IFCR |= DMA_IFCR_CGIF7|DMA_IFCR_CTCIF7|DMA_IFCR_CHTIF7|DMA_IFCR_CTEIF7; // Сброс флага глобального прерывания|флага завершения передачи|флага половинной передачи|флага ошибки передачи
		DMA1_Channel7 -> CMAR = (uint32_t) USART2_TxDataP;	// Записываем в ДМА адрес регистра, откуда забираются данные в ОЗУ
		DMA1_Channel7 ->CNDTR = DatLen;											// Указываем количество передач, которые надо сделать
		USART2 ->SR &= ~USART_SR_TC;												// Сброс бита завершения передачи
		DMA1_Channel7 -> CCR |= DMA_CCR_EN;									// Разрешение канала 7 DMA1  (это канал на передачу USART2)
		return USART_OK;
	}
	else																														// Если предыдущая передача не закончилась
	{
		return USART_Bisy;
	}
}
/*****************************************************************************************************************************************************/

/*************************** Это функция начальной инициализации DMA1 для приема данных из USART2 в буфер ********************************************/
//Перед запуском этой функции нужно инициализировать UART1.
void USART2_DMA_Receive_Init (uint8_t* MemRxDataP, uint32_t BufSize)
{
	RCC->AHBENR |= RCC_AHBENR_DMA1EN;										//Разрешаем тактирование DMA1
	DMA1_Channel6 -> CCR &= ~DMA_CCR_EN;								//Запрещение канала 6 DMA1  (это канал на прием USART2)
	osDelay(1);
	DMA1_Channel6 -> CPAR = (uint32_t)(&(USART2->DR));	//Указываем регистр данных USART2, откуда нужно забирать данные
	DMA1_Channel6 -> CNDTR = BufSize;										//Указываем размер буфера для циклической записи в него
	DMA1_Channel6 -> CMAR = (uint32_t) MemRxDataP;			//Указываем адрес памяти куда складывать данные
	DMA1_Channel6 -> CCR = (DMA_CCR_MINC|DMA_CCR_CIRC); //Вкл инкрементирование адреса чтения из памяти|включение кольцевого режима
	DMA1->IFCR |= DMA_IFCR_CGIF6|DMA_IFCR_CTCIF6|DMA_IFCR_CHTIF6|DMA_IFCR_CTEIF6; // Сброс флага глобального прерывания|флага завершения передачи|флага половинной передачи|флага ошибки передачи
	//USART2 -> CR1 |= USART_CR1_RXNEIE; 									//Разрешение прерывания если регистр приема данных не пуст
	USART2 -> CR3 |= USART_CR3_DMAR; 										//Подключение приемника USART к DMA
	DMA1_Channel6 -> CCR |= DMA_CCR_EN;									//Разрешение канала 6 DMA1  (это канал на прием USART2)
//	__enable_irq ();																		// Глобальное разрешение прерываний
//	NVIC_EnableIRQ(USART2_IRQn);												// Разрешение прерываний от USART2
}
/*****************************************************************************************************************************************************/

/*************************** Это функция начальной инициализации DMA1 для приема данных из USART1 в буфер ********************************************/
//Перед запуском этой функции нужно инициализировать UART1.
void USART1_DMA_Receive_Init (uint8_t* MemRxDataP, uint32_t BufSize)
{
	RCC->AHBENR |= RCC_AHBENR_DMA1EN;										//Разрешаем тактирование DMA1
	DMA1_Channel5 -> CCR &= ~DMA_CCR_EN;								//Запрещение канала 5 DMA1  (это канал на прием USART1)
	osDelay(1);
	DMA1_Channel5 -> CPAR = (uint32_t)(&(USART1->DR));	//Указываем регистр данных USART1, откуда нужно забирать данные
	DMA1_Channel5 -> CNDTR = BufSize;										//Указываем размер буфера для циклической записи в него
	DMA1_Channel5 -> CMAR = (uint32_t) MemRxDataP;			//Указываем адрес памяти куда складывать данные
	DMA1_Channel5 -> CCR = (DMA_CCR_MINC|DMA_CCR_CIRC); //Вкл инкрементирование адреса чтения из памяти|включение кольцевого режима
	DMA1->IFCR |= DMA_IFCR_CGIF5|DMA_IFCR_CTCIF5|DMA_IFCR_CHTIF5|DMA_IFCR_CTEIF5; // Сброс флага глобального прерывания|флага завершения передачи|флага половинной передачи|флага ошибки передачи
	//USART2 -> CR1 |= USART_CR1_RXNEIE; 									//Разрешение прерывания если регистр приема данных не пуст
	USART1 -> CR3 |= USART_CR3_DMAR; 										//Подключение приемника USART к DMA
	DMA1_Channel5 -> CCR |= DMA_CCR_EN;									//Разрешение канала 5 DMA1  (это канал на прием USART1)
//	__enable_irq ();																		// Глобальное разрешение прерываний
//	NVIC_EnableIRQ(USART2_IRQn);												// Разрешение прерываний от USART2
}
/*****************************************************************************************************************************************************/

/*********************** Это функция начальной инициализации DMA1 для передачи данных из памяти в регистр данных USART1 *****************************/
//Перед запуском этой функции нужно инициализировать UART1.
void USART1_DMA_Transmit_Init (void)
{
	RCC->AHBENR |= RCC_AHBENR_DMA1EN;										//Разрешаем тактирование DMA1
	DMA1_Channel4 -> CCR &= ~DMA_CCR_EN;								//Запрещение канала 4 DMA1  (это канал на передачу USART1)
	osDelay(1);
	
	DMA1_Channel4 -> CPAR = (uint32_t)(&(USART1->DR));	//Указываем регистр данных USART2, куда нужно отправлять данные
	DMA1_Channel4 -> CCR = (DMA_CCR_DIR|DMA_CCR_MINC); 	//Чтение из памяти|вкл инкрементирование адреса чтения из памяти
	DMA1->IFCR |= DMA_IFCR_CGIF4|DMA_IFCR_CTCIF4|DMA_IFCR_CHTIF4|DMA_IFCR_CTEIF4; // Сброс флага глобального прерывания|флага завершения передачи|флага половинной передачи|флага ошибки передачи
	USART1 -> CR3 |= USART_CR3_DMAT; 										//Подключение передатчика USART к DMA
	//USART1 ->SR &= ~USART_SR_TC;												// 
	DMA1_Channel4 -> CCR |= DMA_CCR_EN;//|DMA_CCR_TCIE;		// Разрешение канала 4 DMA1 и прерывания по завершении передачи  (это канал на передачу USART1)
	//__enable_irq ();																		// Глобальное разрешение прерываний
	//NVIC_EnableIRQ(DMA1_Channel7_IRQn);									// Разрешение прерываний от седьмого канала DMA1
}
/*****************************************************************************************************************************************************/

/**********************Отправка даныых из контроллера через UART2,DMA1 канал 7************************************************************************/
// uint8_t* USART2_TxDataP - указатель на адрес данных начиная с которого нужно передавать данные.
// uint16_t DatLen - количество байт данных, которое надо передать начиная с адреса uint8_t* USART2_TxDataP
// Перед первым запуском этой функции нужно последовательно проинициализировать UART2 и запустить функцию USART2_DMA_Transmit_Init ()
// Если предыдущая передача не закончилась или интерфейс не инициализирован (void USART1_DMA_Transmit_Init (void)), то функция ничего делать не будет.
USART_DMA_TransmitStatus USART1_DMA_Transmit (uint8_t* USART1_TxDataP, uint16_t DatLen)
{
	if ((USART1 -> CR3 & USART_CR3_DMAT)== 0) return USART_NotInit;	// Если интерфейс не инициализирован
	if((USART1 ->SR & USART_SR_TC))																	// Если предыдущая передача закончилась
	{
		VFD_TransmitON																			// Драйвер RS-485 конфигурируется на передачу
		//osDelay(1);
		DMA1_Channel4 -> CCR &= ~DMA_CCR_EN;								// Запрещение канала 4 DMA1  (это канал на передачу USART1)
		DMA1->IFCR |= DMA_IFCR_CGIF4|DMA_IFCR_CTCIF4|DMA_IFCR_CHTIF4|DMA_IFCR_CTEIF4; // Сброс флага глобального прерывания|флага завершения передачи|флага половинной передачи|флага ошибки передачи
		DMA1_Channel4 -> CMAR = (uint32_t) USART1_TxDataP;	// Записываем в ДМА адрес регистра, откуда забираются данные в ОЗУ
		DMA1_Channel4 ->CNDTR = DatLen;											// Указываем количество передач, которые надо сделать
		USART1 ->SR &= ~USART_SR_TC;												// Сброс бита завершения передачи
		DMA1_Channel4 -> CCR |= DMA_CCR_EN;									// Разрешение канала 7 DMA1  (это канал на передачу USART2)
		return USART_OK;
	}
	else																														// Если предыдущая передача не закончилась
	{
		return USART_Bisy;
	}
}
/*****************************************************************************************************************************************************/


///************************************** Функция читает данные из буфера и передает в порт MP3-плеера *************************************************/
//#pragma push
//#pragma O0
//void MP3Send(void)
//{
//	if (MP3TxBuf1p!=MP3TxBuf2p)																					// Проверяем, появилось ли что - нибудь для отправки в отладочный порт
//	{
//		if (MP3TransferCompleted == 1)																		// Если предыдущая передача по Отладочному порту через DMA завершена
//		{
//			MP3TransferCompleted = 0;																			//Сбрасываем флаг завершения передачи через RS485
//			if (MP3TxBuf1p>MP3TxBuf2p)																	//Если убегающий указатель больше догоняющего
//			{
//				uint16_t SendDataLen = MP3TxBuf1p - MP3TxBuf2p;						//То вычисляем длину куска, который нужно передать
//				USART1_DMA_Transmit (&MP3TxBuf[MP3TxBuf2p], SendDataLen);	//Передаем кусок данных через DMA
//				MP3TxBuf2p = MP3TxBuf1p;																	//Приравниваем догоняющую метку к убегающей
//			}
//			else if (MP3TxBuf1p<MP3TxBuf2p)
//			{
//				uint16_t SendDataLen = MP3TxBufSize - MP3TxBuf2p;					//То вычисляем длину куска, который нужно передать до конца буфера
//				USART1_DMA_Transmit (&MP3TxBuf[MP3TxBuf2p], SendDataLen);	//Передаем кусок данных через DMA
//				MP3TxBuf2p = 0;																							//Ставим догоняющую метку на начало буфера
//			}
//		}
//	}
//}
//#pragma pop
/*****************************************************************************************************************************************************/
/*****************************************************************************************************************************************************/
/*****************************************************************************************************************************************************/
/*****************************************************************************************************************************************************/
/*****************************************************************************************************************************************************/
/**/
