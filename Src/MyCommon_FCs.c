#include "MyCommon_FCs.h"
#include "stm32f103xe.h"
#include "MyDefines.h"
#include "cmsis_os.h"



		/*-----------------------Функция преобразует младшую половину байта в число которое обозначает эту цыфру в кодировке ASCII------------------------------------*/
		uint8_t HalfbyteToHexascii(uint8_t halfbyte)
		{
			halfbyte &= 0x0F ;
			if(halfbyte >= 10) return('A' + halfbyte - 10) ; 
			else               return('0' + halfbyte) ; 
		}
		/**************************************************************************************************************************************************************/
		
		/*******************Функция преобразует число из 32-х разрядного Hex в десятичный ASCII************************************************************************/
		//uint32_t HexData - 32-х разрядное число, которое будет преобразовываться
		//uint8_t *DecASCII - указатель на массив, где будет сохраняться результат преобразования в виде строки с 0 в конце Массив должен быть из 11 элементов 
		#pragma push
		#pragma O0
		void Hex32ToDecASCII (uint32_t HexData, uint8_t *DecASCII)
		{	
			uint8_t razr[10];
			razr[0] = HexData / 1000000000U;
			HexData %= 1000000000U;
			razr[1] = HexData / 100000000U;
			HexData %= 100000000U;
			razr[2] = HexData / 10000000U;
			HexData %= 10000000U;
			razr[3] = HexData / 1000000U;
			HexData %= 1000000U;
			razr[4] = HexData / 100000U;
			HexData %= 100000U;
			razr[5] = HexData / 10000U;
			HexData %= 10000U;
			razr[6] = HexData / 1000U;
			HexData %= 1000U;
			razr[7] = HexData / 100U;
			HexData %= 100U;
			razr[8] = HexData / 10U;
			razr[9] = HexData % 10U;
			uint8_t LenCounter = 0;
			while ((razr[LenCounter] == 0) && (LenCounter < 9U))	//В этом цикле ищется первый не нулевой элемент. LenCounter станет номером первого не нулевого элемента
			{
				LenCounter++;
			}
			for(uint8_t i = 0;  i<=9; i++)
			{
				*(DecASCII + i) = (LenCounter <= 9) ? HalfbyteToHexascii(razr[LenCounter++]) : 0U;
				*(DecASCII + i+1) = 0U;
				//if (LenCounter > 9) break;
			}
			return;
		}
		#pragma pop
		/**************************************************************************************************************************************************************/
		
		/***********функция берет число от 0 до F в ASCII кодировке и преобразовывать в обычный hex.*************************-----------------------------------------*/
		uint8_t HexAsciiToHalfbyteHex(uint8_t _ascii)
		{
		 if((_ascii >= '0') && (_ascii <= '9')) return(_ascii - '0') ; 
		 if((_ascii >= 'a') && (_ascii <= 'f')) return(_ascii - 0x57) ; 
		 if((_ascii >= 'A') && (_ascii <= 'F')) return(_ascii - 0x37) ; 
		 return(0xFF);
		}
		/***************************************************************************************************************************************************************/
		
		/****************************  Функция берет данные из массива, где они записаны в АСКИ в десятичном виде и преобразует в 32 разрядный Hex  ********************/
		uint32_t DecAsciiToHex32 (uint8_t *DecASCII)
		{
			uint32_t Hex32 = 0;															//Переменная для хранения преобразованного шестнадцатеричного числа
			int8_t DatLenCounter =0;												//Счетчик количества символов десятичного числа в ASCII кодировке
			uint8_t Dec[10];																//Массив, куда складываются десятичные числа преобразованные из ASCII в Hex
			while (DecASCII[ DatLenCounter] !=0)						//Если текущий символ не равен 0, то конец строки не настал
			{
				Dec[DatLenCounter] = HexAsciiToHalfbyteHex(DecASCII[DatLenCounter]);	//Преобразуем ASCII символ в Hex и сохраняем в массиве Dec
				DatLenCounter++;
				if (DatLenCounter >=10) break;								// Если счетчик DecASCII символов превысил 10, то выскакиваем из цикла (10-Й СИМВОЛ - ЭТО 0 В КОНЦЕ СТРОКИ )
			}
			DatLenCounter--;																//Откатываемся на 1 символ так как 0 в конце строки нам не нужен
			uint32_t multiplier = 1U;												//Множитель, соответствующий текущему разряду десятичного числа 

			while (DatLenCounter >= 0)
			{
				Hex32 += Dec[DatLenCounter] * multiplier;
				DatLenCounter--;
				if (DatLenCounter < 0) break;									//Если счетчик разрядов меньше 0, то выскакиваем из цикла, чтобы не переполнить  multiplier за 32 разряда
				multiplier *=10U;															//увеличиваем множитель в 10, так как у следующего символа вес больше в 10 раз
			}
			return Hex32;
		}
		/***************************************************************************************************************************************************************/
		
		/*************************************** CRC8n Функция от Нафиса  **********************************************************************************************/
		//Перед началом рассчетов, переменную, куда будет складываться CRC, нужно инициализировать нулями
		void CRC8n (uint8_t in, uint8_t *crc)
		{
				#define POLYNOMIAL 0x1D // x^8 + x^4 + x^3 + x^2 + 1
				*crc = *crc ^ in;
				for (unsigned char i=0; i<8; i++)
				{
						*crc = (*crc & 0x80)? (*crc << 1) ^ POLYNOMIAL : (*crc << 1);    
				}
		}
		/***************************************************************************************************************************************************************/
		
		/***************************   CRC16 Функция от Нафиса   *********** polinom 0x1021=CCIT ***********************************************************************/
		// Crc16Mod(crc8_tbl,256,0x1021);
		unsigned short Crc16Mod (unsigned char *pcBlock, unsigned short len, unsigned short APolynome )
		{
		unsigned short crc = 0xFFFF;
		while (len--)
			{
			crc ^= *pcBlock++;
			for (int i = 0; i < 8; i++) crc = crc & 0x0001 ? (crc >> 1) ^ APolynome : crc >> 1;
			}
		 //crc = crc>>8 ^ crc<<8; //менять местами
		return crc;
		}
		/***************************************************************************************************************************************************************/

		/***************************   CRC16 Функция для расчета CRC16 в кольцесом буфере***** polinom 0x1021=CCIT *****************************************************/
		// Crc16Mod(crc8_tbl,256,0x1021);
		// uint8_t *Buf - указатель на буфер в котором считаем CRC
		// uint32_t Buf2p - догоняющая метка буфера
		// uint32_t BufSize - размер буфера
		// unsigned short len - длина блока данных в буфере, для которых подсчитываем CRC
		// unsigned short APolynome - полином, по которому расчитываем  CRC
		// unsigned short *crc - расчитаный CRC
		// return Buf2p - возвращает догоняющий индекс, который указывает на элемент буфера, следующий за блоком данных
		uint32_t Crc16Buf (uint8_t *Buf, uint32_t Buf2p, uint32_t BufSize, uint16_t len, uint16_t APolynome, uint16_t *crc)
		{
		*crc = 0xFFFF;
		while (len--)
			{
			*crc ^= Buf[Buf2p++];
			Buf2p %= BufSize;
			for (int i = 0; i < 8; i++) *crc = *crc & 0x0001 ? (*crc >> 1) ^ APolynome : *crc >> 1;
			}
		 //crc = crc>>8 ^ crc<<8; //менять местами
		return Buf2p;
		}
		/***************************************************************************************************************************************************************/
		
		/****************************  Функция берет данные из массива, где они записаны в АСКИ в десятичном виде и преобразует в 32 разрядный Hex  ********************/
		// char *simv - ASCII символ, до обнаружения которого нужно искать в буфере данные и преобразовывать в hex
		// uint8_t *Buf - указатель на буфер, где нужно искать данные
		// uint32_t Buf1p - убегающая метка буфера
		// uint32_t *Buf2p - указатель на догоняющую метку
		// uint32_t SizeOfBuf - размер буфера в котором ищем
		uint32_t DecAsciiToHex32_ (char *simv, uint8_t *Buf, uint32_t Buf1p, uint32_t *Buf2p, uint32_t SizeOfBuf)
		{
			uint32_t Hex32 = 0;															//Переменная для хранения преобразованного шестнадцатеричного числа
			int8_t DatLenCounter =0;												//Счетчик количества символов десятичного числа в ASCII кодировке
			uint8_t Dec[10];																//Массив, куда складываются десятичные числа преобразованные из ASCII в Hex
			if(DataIntoBufIsExhaused (Buf1p, Buf2p)) {return 0xFFFFFFFF;}	//Если данные в буфере закончились, а новые не приходят, то выходим из функции со значением 0xFFFFFFFF
			
			while (Buf[*Buf2p] != *simv)										//Если текущий символ не равен *simv, то конец строки не настал
			{
				
				if(*Buf2p == Buf1p) 													// Если догоняющая метка буфера догнала убегающую 
				{
					osDelay(20);																// То ждем 20 мс
					if(*Buf2p == Buf1p) {return 0;}							// И если метка так и не убежала, то выходим из функции
				}
				
				Dec[DatLenCounter] = HexAsciiToHalfbyteHex(Buf[*Buf2p]);	//Преобразуем ASCII символ в Hex и сохраняем в массиве Dec
				*Buf2p = *Buf2p + 1;														// Увеличиваем значение буфера на 1
				*Buf2p %= SizeOfBuf;														// Закольцовываемся
				DatLenCounter++;
				if (DatLenCounter >=10) break;									// Если счетчик DecASCII символов превысил 10, то выскакиваем из цикла (10-Й СИМВОЛ - ЭТО 0 В КОНЦЕ СТРОКИ )
			}
			*Buf2p = *Buf2p + 1;															// Увеличиваем значение буфера на 1
			*Buf2p %= SizeOfBuf;															// Закольцовываемся
			
			DatLenCounter--;																//Откатываемся на 1 символ так как 0 в конце строки нам не нужен
			uint32_t multiplier = 1U;												//Множитель, соответствующий текущему разряду десятичного числа 

			while (DatLenCounter >= 0)
			{
				Hex32 += Dec[DatLenCounter] * multiplier;
				DatLenCounter--;
				if (DatLenCounter < 0) break;									//Если счетчик разрядов меньше 0, то выскакиваем из цикла, чтобы не переполнить  multiplier за 32 разряда
				multiplier *=10U;															//увеличиваем множитель в 10, так как у следующего символа вес больше в 10 раз
			}
			return Hex32;
		}
		/***************************************************************************************************************************************************************/

		/*******************Функция возвращает 1 если данные в буфере GPRxBuf закончились и 0 если необработанные данные еще есть****************************************/
		// Buf1p - указатель на убегающую метку буфера
		// Buf2p - указатель на убегающую метку буфера
		uint8_t DataIntoBufIsExhaused (uint32_t Buf1p, uint32_t *Buf2p)	
		{
			if(*Buf2p == Buf1p) 										// Если догоняющая метка буфера догнала убегающую 
				{
					osDelay(20);												// То ждем 20 мс
					if(*Buf2p == Buf1p) {return 1;}			// И если метка так и не убежала, то выходим из функции возвращая 1 
				}
			return 0;																// Если метка убежала , то выходим из функции возвращая 0
		}
		/****************************************************************************************************************************************************************/
		
		/***************************************Задержка через NOP***************************************************************************/
		//NopNumber - количество пустых операций, которые нужно выполнить во время ожидания
		#pragma push
		#pragma O0
		void NopDelay (uint32_t NopNumber)
		{
			for(uint32_t i = 0; i<NopNumber; i++)
			{
				__NOP();
			}
		}
		#pragma pop
		/****************************************************************************************************************************************************************/
		
		/**********************************************************************Фильтр Калмана (упрощенный)***************************************************************/
		// Функция возвращает заначение отфильтрованное по упрощеннному Калмановскому алгоритму
		// float Kstab - Коэффициент Калмана (значение от 0 до 1). Чем больше Kstab, тем больше вклад величины, полученной от датчика, в итоговое значение *Xopt
		// float *Xopt - Оптимальное приближение, полученное в результате предыдущего вычисления (должно быть объявлено как глобальная переменная)
		// float *z - указатель на значение полученное от датчика
		#pragma push
		#pragma O0
		float Kalman (float Kstab, float *Xopt, float *z)
		{
			*Xopt = ((Kstab * *z)+((1-Kstab) * *Xopt));
			return *Xopt;
		}
		#pragma pop
		/****************************************************************************************************************************************************************/
		
		/*********************************************************Возвращает модуль числа********************************************************************************/
		float ABSfloat (float a)
		{
			if(a>=0)
			{
				return a;
			}
			else
			{
				return (a*(-1));
			}
		}
		/****************************************************************************************************************************************************************/
		
		/*****************************************************************Сравнение двух строк***************************************************************************/
		//Функция сравнивает 2 строки до первого нуля в любой из них
		//Если строки совпали, то фозвращает длину строки, а если нет - то ноль
		#pragma push
		#pragma O0
		uint32_t TwoStrCmp (char *Str1, char *Str2)	
		{
			uint32_t StrLen = 0;																		//Создаем переменную, где будет лежать длина строки
			while ( (*(Str1+StrLen) != 0)&&(*(Str2+StrLen) != 0))		//Ищем, пока не встретим в строке 0.
			{
					if (*(Str1+StrLen) == *(Str2+StrLen))								//Если символы совпадают
					{
						StrLen++;																					//то инкрементируем StrLen
					}																										// и продолжаем сравнивать следующие компоненты
					else
					{
						return 0;																					// А если хотя бы один символ не совпал, то выходим из функции и возвращаеи 0
					}
			}
			if (*(Str1+StrLen) != *(Str2+StrLen))										//Когда в одной из строк найден нулевой символ и при этом во второй строке на этой же позиции не ноль, то тогда строки не равны 
			{
				return 0;																							//Возвращаем ноль
			}
			return StrLen;																					//Если все символы совпали, то возвращаем длину строки
		}
		#pragma pop
		/****************************************************************************************************************************************************************/
		
		/*************  Функция ищет строку в буфере и возвращает 0 если в буфере такой строки не нашлось или длину строки, если строка нашлась  **************/
		// uint8_t *StrForSerch - это указатель на строку, которую ищем
		// uint8_t *Buf - Указатель на начало буфера в котором ищем
		// uint32_t Buf1p - Указатель на убегающую метку буфера в котором ищем
		// uint32_t *Buf2p - Указатель на догоняющую метку буфера в котором ищем
		// uint32_t BufSize - Размер буфера

//		#pragma push																			//Запаминаем уровень оптимизации
//		#pragma O0	
		uint32_t StrCmpV3 (char *StrForSerch, uint8_t *Buf, uint32_t *Buf2p, uint32_t Buf1p, uint32_t BufSize)	
		{
			uint8_t StrLen = 0;																		//Создаем переменную, где будет лежать длина строки
			uint32_t TempGPRxBuf2p = *Buf2p;											//Копируем догоняющую метку буфера во временную переменную
			
			while ( StrForSerch[StrLen] != 0 )									//Ищем, пока не встретим в строке 0.
			{
					if (StrForSerch[StrLen] == Buf [TempGPRxBuf2p])		//Если символ в буфере совпал с символом в искомой строке
					{
						if(TempGPRxBuf2p == Buf1p)											//Если догоняющая метка буфера догнола убегающую 
						{
							osDelay(20);																	//То ждем 20 мс
							if(TempGPRxBuf2p == Buf1p){return 0;}				//И если метка так и не убежала, то выходим из функции
						}
						StrLen++;																					//, то инкрементируем StrLen и указатель на эллемент буфера
						TempGPRxBuf2p++;
						TempGPRxBuf2p %= BufSize;													// не забывая закольцеваться
					}																										// и продолжаем сравнивать следующие компоненты
				else
					{
						return 0;																					// А если хотя бы один символ не совпал, то выходим из функции и возвращаеи 0
					}
			}
			*Buf2p = TempGPRxBuf2p;													//Если строка найдена, то обновляем значение догоняющей метки буфера
			osDelay(15);
			return StrLen;																	//И возвращаем длину строки
		}
//		#pragma pop	
		/*******************************************************************************************************************************************************/
		
		/************************************* Преобразует шестнадцатеричное число, записанное в ASCII в однобайтовый Hex **************************************/
		uint8_t DecAsciiToHex8 (uint8_t ASCII_H, uint8_t ASCII_L)
		{
			uint8_t Hex8 = 0;
			Hex8 = (HexAsciiToHalfbyteHex(ASCII_H) << 4);
			Hex8 |= HexAsciiToHalfbyteHex(ASCII_L);
			return Hex8;
		}
		/*******************************************************************************************************************************************************/
		/****************************************Распечатывает статус выполнения функции HAL в отладочный порт**************************************************/
		// char *StrP - Здесь вписываем строку которая указывает на то, какая HAL функция вернула статус выполнения
		// HAL_StatusTypeDef Stat - Сюда передаем статус выполнения HAL функции
		
//		void PrnHAL_Status(char *StrP, HAL_StatusTypeDef Stat)
//		{
//			PrnDP_Buf(StrP);								// Распечатываем строку которая указывает на результат выполнения HAL функции
//			if (Stat == HAL_OK)							// Здесь печатаем варианты выполнения
//			{
//				PrnDP_Buf ("HAL_OK\r\n");
//			}
//			else if (Stat == HAL_ERROR)
//			{
//				PrnDP_Buf ("HAL_ERROR\r\n");
//			}
//			else if (Stat == HAL_BUSY)
//			{
//				PrnDP_Buf ("HAL_BUSY\r\n");
//			}
//			else if (Stat == HAL_TIMEOUT)
//			{
//				PrnDP_Buf ("HAL_TIMEOUT\r\n");
//			}
//			else
//			{
//				PrnDP_Buf ("Unnown ERROR\r\n");
//			}
//		}
		/*******************************************************************************************************************************************************/
		/*******************************************Выдает величину заполненного объема буфера******************************************************************/
		//uint32_t *Buf1p - убегающая метка буфера
		//uint32_t *Buf2p - догоняющая метка буфера
		//uint32_t SizeOfBuf - размер буфера в котором ищем
		uint32_t GetFilledBufSpace(uint32_t *Buf1p, uint32_t *Buf2p, uint32_t BufSize)
		{
			if (*Buf1p >= *Buf2p)
			{
				return *Buf1p - *Buf2p;
			}
				else 
			{
				return BufSize - *Buf2p + *Buf1p;
			}
		}
		/*******************************************************************************************************************************************************/
		/*********************************************** Функция создает заголовок пакета 5517 и сохраняет его в буфер *****************************************/
		// uint8_t DeviceType - Тип устройства. Константа 04h. Исключение: в первом пакете значение = 15h
		// uint16_t DataFildLenght - Длинна поля "Данные"
		// uint8_t* Buf - адрес начала буфера, куда сохраняется заголовок
		// uint32_t* Buf1p - убегающий индекс буфера, куда сохраняется заголовок
		// uint32_t BufSize - размер буфера, куда сохраняется заголовок
		void CreateHeader(uint8_t DeviceType, uint16_t DataFildLenght, uint8_t* Buf, uint32_t* Buf1p, uint32_t BufSize)
		{
			uint8_t TmpHeaderMsv[7]; 				// Создаем массив под заголовок пакета 5517
			TmpHeaderMsv[0] = 0x55U;				// Преамбула 55
			TmpHeaderMsv[1] = 0x17U;				// Преамбула 17
			TmpHeaderMsv[2] = DeviceType;		// Тип устройства				
			TmpHeaderMsv[3] = 0;						// Битовое поле
			TmpHeaderMsv[4] = (uint8_t)((DataFildLenght>>8)&0x03);  // Счетчик пакетов и старшие 2 байта длины поля данных
			TmpHeaderMsv[5] = (uint8_t) DataFildLenght;							// Младшие 8 бит длины поля данных
			for(uint8_t i = 0; i < 6; i++)				// Считаем CRC для заголовка
			{
				CRC8n (TmpHeaderMsv[i], &TmpHeaderMsv[6]);
			}
			uint32_t TmpBuf1p = *Buf1p;
			for(uint8_t i = 0; i < 7; i++)		// Копируем данные в буфер
			{
				Buf[TmpBuf1p] = TmpHeaderMsv[i];
				TmpBuf1p++;
				TmpBuf1p %= BufSize;
			}
			*Buf1p = TmpBuf1p;
		}
		/*******************************************************************************************************************************************************/
		/*******************************************************************************************************************************************************/
		uint32_t htonl(uint32_t n)
		{
			uint32_t tmp;

			tmp = n ^ ((n << 16) | (n >> 16));
			tmp &= ~0x00ff0000;
			n = (n << 24) | (n >> 8);
			n ^= (tmp >> 8);

			return n;
		}
		/*******************************************************************************************************************************************************/
		/*******************************************************************************************************************************************************/
//		uint32_t htonl(uint32_t n)
//		{
//			uint32_t tmp;

//			tmp = n ^ ((n << 16) | (n >> 16));
//			tmp &= ~0x00ff0000;
//			n = (n << 24) | (n >> 8);
//			n ^= (tmp >> 8);

//			return n;
//		}
		/*******************************************************************************************************************************************************/
		/*******************************************************************************************************************************************************/
		/*******************************************************************************************************************************************************/
		/*******************************************************************************************************************************************************/
		/*******************************************************************************************************************************************************/
		/*******************************************************************************************************************************************************/
		/*******************************************************************************************************************************************************/
		/**/
